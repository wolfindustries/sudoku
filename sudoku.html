<!DOCTYPE html>
<head>
    <style type="text/css">
        html 
        {
            font-family:Arial, Helvetica, sans-serif;
            background-color:#333;
        }

        div#gameWrap {
            position:absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -49%);
        }

        div#upperControls {
            display: grid;
            grid-auto-flow: row;
            grid-template-columns: 1fr 1fr;
        }

        div#upperControls label {
            display: inline-grid;
            padding: 10px;
            margin:20px;
            background-color:#fff;
            border-radius:5px;
        }

        div#lowerControls {
            display:grid;
            grid-auto-flow: column;
        }

        div#lowerControls div.subControl {
            position:relative;
            margin:10px;
            background-color:#39f;
            border-radius:5px;
        }

        div#lowerControls p.primary {
            text-align: center;
            font-size: 2.4em;
            margin: 0.1em 0;
        }

        div#lowerControls p.remaining {
            text-align: right;
            position: absolute;
            font-size:0.9em;
            top: 3px;
            right: 3px;
            margin: 0;
        }

        div.section {
            border:2px solid #000;
        }

        div#main {
            width:600px;
            height:600px;
        }

        div#main, div.section {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            grid-auto-flow: column;
        }

        div.cell {
            display:flex;
            justify-content: center;
            align-items: center;
            border:1px solid #000;
            margin:-1px -1px 0 0;
            background-color:#fff;
        }

        div.cell.highlight {
            background-color:#a5a5a5;
        }

        div.cell.lowlight {
            background-color:#e1e1e1;
        }

        div.cell p.display {
            margin:0;
            padding:0;
            font-size:2em;  
            text-align: center;
        }

        div.cell p.display.assigned {
            color:blue;
        }

        div.cell p.display.fixed {
            color:#000;;
        }

        div.cell p.display.error {
            color:red;
        }

        div.cell p.hint {
            margin:0 0 2.8em 0;
            padding:0;
            font-size:1em;
            text-align: center;
            position:absolute;
        }
    </style>
</head>
<body>
    <div id="gameWrap">
        <div id="upperControls"></div>
        <div id="main"></div>
        <div id="lowerControls"></div>
    </div>
</body>
</html>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", ()=> {
    setupSudoku();
})

function setupSudoku()
{
    let main = document.getElementById("main");
    let upperControls = document.getElementById("upperControls");
    let lowerControls = document.getElementById("lowerControls");
    let sudoku = new Sudoku(main, upperControls, lowerControls);

    //generateBoard();
}

class Cell
{
    constructor(sudoku, gridX, gridY, cellX, cellY) {
        this.sudoku = sudoku;

        this.div = document.createElement("div");
        this.div.setAttribute("class", "cell");

        this.display = document.createElement("p");
        this.display.innerText = "0";
        this.display.setAttribute("class", "display");
        this.div.append(this.display);

        this.hint = document.createElement("p");
        this.hint.innerText = gridX + "," + gridY + " " + cellX + "," + cellY;
        this.hint.setAttribute("class", "hint");
        this.div.append(this.hint);

        this.gridX = gridX;
        this.gridY = gridY;
        this.cellX = cellX;
        this.cellY = cellY;

        this.playerCanChange = true;
        this.currentValue = "";
        this.setCurrentValue("");

        this.div.addEventListener("click", () => {
            sudoku.clickOnCell(gridX, gridY, cellX, cellY);
        })
    }

    setCurrentValue(val)
    {
        if(this.playerCanChange)
        {
            this.currentValue = val;
            this.display.innerText = "" + val;
        }
    }

    setAdjacentSelected()
    {
        this._addClass("lowlight");
    }

    setSelected() 
    {
        this._addClass("highlight");
        this._removeClass("lowlight");
    }

    setUnselected()
    {
        this._removeClass("highlight");
        this._removeClass("lowlight");
    }

    setPlayerCanChange(val)
    {
        this.playerCanChange = val;
    }

    _addClass(className)
    {
        this.div.classList.add(className);
    }

    _removeClass(className)
    {
        this.div.classList.remove(className);
    }
}

class ControlButton
{
    constructor(index)
    {
        this.index = index;

        this.div = document.createElement("div");
        this.div.classList.add("subControl");
        
        this.text = document.createElement("p");
        this.text.classList.add("primary");
        this.text.innerHTML = this.index;

        this.remaining = document.createElement("p");
        this.remaining.classList.add("remaining");
        this.remaining.innerHTML = this.index;

        this.div.append(this.text);
        this.div.append(this.remaining);
    }
}

class Sudoku 
{
    constructor(parent, upperControls, lowerControls)
    {
        this.parent = parent;
        this.grid = Array();

        this.buildStepsCount = 0;
        this.assigningCount = 0;
        this.clearingCount = 0;

        this.upperControls = upperControls;
        this.lowerControls = lowerControls;
        this.controls = new SudokuControls(this.upperControls, this.lowerControls);

        this.currentCell = null;

        this.build();

        this.bindEventHandlers();
    }

    bindEventHandlers()
    {
        document.addEventListener("keydown", (e) => {
            if(e.key >= 0 && e.key <= 9)
            {
                if(this.currentCell != null)
                {
                    this.currentCell.setCurrentValue(e.key)
                }
            }
        })

        document.addEventListener("click", (e) => {
            if(!this.parent.contains(event.target))
            {
                this._doThingToAllTiles(this._clearHighlightsAndLowlights);
                this.currentCell = null;
            }
        })
    }

    build()
    {
        for(var gridX = 0; gridX < 3; gridX++)
        {
            for(var gridY = 0; gridY < 3; gridY++)
            {
                var section = document.createElement("div");
                section.setAttribute("class", "section");

                for(var cellX = 0; cellX < 3; cellX++)
                {
                    for(var cellY = 0; cellY < 3; cellY++)
                    {
                        var cell = new Cell(this, gridX, gridY, cellX, cellY);

                        section.append(cell.div);
                        
                        this.addToArr(gridX, gridY, cellX, cellY, cell);
                    }
                }

                main.append(section);
            }
        }

        this.populateBoard();
        this.adjustToDifficulty();
    }

    addToArr(gridX, gridY, cellX, cellY, cell)
    {
        if(!this.grid[gridX])
        {
            this.grid[gridX] = new Array();
        }
        if(!this.grid[gridX][gridY])
        {
            this.grid[gridX][gridY] = new Array();
        }
        if(!this.grid[gridX][gridY][cellX])
        {
            this.grid[gridX][gridY][cellX] = new Array();
        }

        this.grid[gridX][gridY][cellX][cellY] = cell;
    }

    adjustToDifficulty()
    {
        var tilesToRemove = this.controls.countInput.value;

        while(tilesToRemove > 0)
        {
            var cell = this._getRandomCell();

            if(cell.currentValue != "")
            {
                cell.setCurrentValue("");
                tilesToRemove--;
            }
            this.buildStepsCount++;
        }
    }

    checkColFor(gridX, cellX, val)
    {
        var cells = this._getCol(gridX, cellX);

        cells.forEach(cell => {
            this.buildStepsCount++;
            
            if(cell.currentValue == val)
            {
                return false;
            }
        })

        return true;
    }

    checkGridFor(gridX, gridY, val) 
    {
        var cells = this._getGrid(gridX, gridY);

        cells.forEach(cell => {
            this.buildStepsCount++;
            
            if(cell.currentValue == val)
            {
                return false;
            }
        })
        
        return true;
    }

    checkRowFor(gridY, cellY, val)
    {
        var cells = this._getRow(gridY, cellY);
        
        cells.forEach(cell => {
            this.buildStepsCount++;

            if(cell.currentValue == val)
            {
                return false;
            }
        })

        return true;
    }

    clearValueFromBoard(value)
    {
        //console.log("clearing " + value);
        for(var i = 0; i < 9; i++)
        {
            var gridX = Math.floor(i / 3);
            var gridY = i % 3;
            for(var j = 0;  j < 9; j++) {
                var cellX = Math.floor(j / 3);
                var cellY = j % 3;
                if(this.grid[gridX][gridY][cellX][cellY].currentValue == value)
                {
                    this.grid[gridX][gridY][cellX][cellY].setCurrentValue("");
                }
                this.buildStepsCount++;
            }
        }
    }

    clickOnCell(gridX, gridY, cellX, cellY)
    {
        console.log(gridX + " " + gridY);
        this._doThingToAllTiles(this._clearHighlightsAndLowlights);

        var cells = new Array();
        cells.push(...this._getRow(gridY, cellY));
        cells.push(...this._getCol(gridX, cellX));
        cells.push(...this._getGrid(gridX, gridY));
        
        cells.forEach(cell => {
            cell.setAdjacentSelected();
        })

        this.grid[gridX][gridY][cellX][cellY].setSelected();
        this.currentCell = this.grid[gridX][gridY][cellX][cellY];
    }

    preAssignValue(value, overallDepth = 0)
    {
        var grids = new Array();
        var cells = new Array();
        for(var i = 0; i < 9; i++)
        {
            grids.push(i);
            cells.push(i);
        }

        var stackDepth = 0;
        //console.log("assigning " + value);

        while(stackDepth < 60 && grids.length > 0 && cells.length > 0) {
            var gPos = Math.floor(Math.random() * grids.length);
            var gridY = Math.floor(grids[gPos] / 3);
            var gridX = grids[gPos] % 3;
            var cPos = Math.floor(Math.random() * cells.length);
            var cellY = Math.floor(cells[cPos] / 3);
            var cellX = cells[cPos] % 3;
            this.buildStepsCount++;
            //console.log(grids[gPos] + " " + gridX + "," + gridY + " | " + cells[cPos] + " " + cellX + "," + cellY);

            if(this.grid[gridX][gridY][cellX][cellY].currentValue == 0)
            {
                if(this.checkGridFor(gridX, gridY, value))
                {
                    if(this.checkColFor(gridX, cellX, value))
                    {
                        if(this.checkRowFor(gridY, cellY, value)) {
                            var cell = this.grid[gridX][gridY][cellX][cellY];
                            cell.setCurrentValue(value);

                            //console.log("remove " + grids[gPos] + " from grid");
                            grids.splice(gPos, 1);
                            //console.log("remove " + cells[cPos] + " from cells");
                            cells.splice(cPos, 1);
                        }
                    }
                }
            }

            stackDepth++;
        }

        if(stackDepth > 59) 
        {
            //console.log("error out due to stack-depth");
            this.clearingCount++;
            this.clearValueFromBoard(value);

            overallDepth++;
            if(overallDepth >= 5)
            {
                //console.log("number limit reached");
                return false;
            }
            else
            {
                //console.log("trying number again");
                return this.preAssignValue(value, overallDepth += 1);
            }
        }
        this.assigningCount++;
        return true;
    }

    populateBoard()
    {
        var sectionVals = Array();
        for(var i = 1; i < 10; i++)
        {
            sectionVals.push(i);
        }
        var clearedVals = Array();

        while(sectionVals.length > 0 && this.buildStepsCount < 1000000) {
            var randomValue = Math.floor(Math.random() * sectionVals.length);

            if(this.preAssignValue(sectionVals[randomValue], 0))
            {
                //console.log("assigned " + sectionVals[randomValue]);
                clearedVals.push(sectionVals[randomValue]);
                sectionVals.splice(randomValue, 1);
            }
            else
            {
                //console.log("removing " + clearedVals[clearedVals.length - 1] + " and trying again");
                this.clearValueFromBoard(clearedVals[clearedVals.length - 1]);
                sectionVals.push(clearedVals[clearedVals.length - 1]);
                clearedVals.pop();
            }
        }

        //console.log("done building board with " + this.buildStepsCount + " steps, " + this.assigningCount + " assigns, " + this.clearingCount + " clears");
    }

    _clearHighlightsAndLowlights(el)
    {
        el.setUnselected();
    }

    _doThingToAllTiles(action)
    {
        for(var gPos = 0; gPos < 9; gPos++)
        {
            var gridX = Math.floor(gPos / 3);
            var gridY = gPos % 3;

            for(var cPos = 0; cPos < 9; cPos++)
            {
                var cellX = Math.floor(cPos / 3);
                var cellY = cPos % 3;

                action(this.grid[gridX][gridY][cellX][cellY]);
            }            
        }
    }

    _getCol(gridX, cellX)
    {
        var arr = new Array();
        for(var gridY = 0; gridY < 3; gridY++)
        {
            for(var cellY = 0; cellY < 3; cellY++)
            {
                arr.push(this.grid[gridX][gridY][cellX][cellY]);
            }
        }
        return arr;
    }

    _getGrid(gridX, gridY)
    {
        var arr = new Array();
        for(var cellX = 0; cellX < 3; cellX++)
        {
            for(var cellY = 0; cellY < 3; cellY++)
            {
                arr.push(this.grid[gridX][gridY][cellX][cellY]);
            }
        }
        return arr;
    }

    _getRandomCell()
    {
        var gPos = Math.floor(Math.random() * 9);
        var gridX = Math.floor(gPos / 3);
        var gridY = gPos % 3;
        var cPos = Math.floor(Math.random() * 9);
        var cellX = Math.floor(cPos / 3);
        var cellY = cPos % 3;

        return this.grid[gridX][gridY][cellX][cellY];
    }

    _getRow(gridY, cellY)
    {
        var arr = new Array();
        for(var gridX = 0; gridX < 3; gridX++)
        {
            for(var cellX = 0; cellX < 3; cellX++)
            {
                arr.push(this.grid[gridX][gridY][cellX][cellY]);
            }
        }
        return arr;
    }
}

class SudokuControls
{
    constructor(upperControls, lowerControls, sudokuController)
    {
        this.div = document.createElement("div");
        this.div.setAttribute("class", "tileSlider");

        this.upperControls = upperControls;
        this.lowerControls = lowerControls;
        
        this.countLabel = document.createElement("label");
        this.countLabel.innerHTML = "Set Difficulty (Easy > Hard):";

        this.countInput = document.createElement("input");
        this.countInput.setAttribute("type", "range");
        this.countInput.setAttribute("min", 2);
        this.countInput.setAttribute("max", 80);
        this.countInput.value = 40;

        this.countLabel.append(this.countInput);
        this.upperControls.append(this.countLabel);

        this.refreshLabel = document.createElement("label");
        this.refreshLabel.innerHTML = "Reset Board:";

        this.refreshInput = document.createElement("input");
        this.refreshInput.setAttribute("type", "button");
        this.refreshInput.value = "Reset";

        this.refreshLabel.append(this.refreshInput);
        this.upperControls.append(this.refreshLabel);

        this.buttons = new Array();
        for(var i = 1; i < 10; i++) {
            var button = new ControlButton(i);
            this.buttons.push(i);
            this.lowerControls.append(button.div);
        }

        return this;
    }
}
</script>