<!DOCTYPE html>
<head>
    <style type="text/css">
        html 
        {
            font-family:Arial, Helvetica, sans-serif;
            background-color:#333;
        }
        div#main {
            width:600px;
            height:600px;
            position:absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -49%);
        }

        div.section {
            border:2px solid #000;
        }

        div#main, div.section {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            grid-auto-flow: column;
        }

        div.cell {
            display:flex;
            justify-content: center;
            align-items: center;
            border:1px solid #000;
            margin:-1px -1px 0 0;
            background-color:#fff;
        }

        div.cell p.display {
            margin:0;
            padding:0;
            font-size:2em;  
            text-align: center;
        }

        div.cell p.hint {
            margin:0 0 2.8em 0;
            padding:0;
            font-size:1em;
            text-align: center;
            position:absolute;
        }
    </style>
</head>
<body>
<div id="main"></div>
</body>
</html>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", ()=> {
    setupSudoku();
})

function setupSudoku()
{
    let main = document.getElementById("main");
    let sudoku = new Sudoku(main);

    //generateBoard();
}

function _checkRowFor(gY, cY, val)
{

}

class Cell {
    constructor(gridX, gridY, cellX, cellY) {
        this.div = document.createElement("div");
        this.div.setAttribute("class", "cell");

        this.display = document.createElement("p");
        this.display.innerText = "0";
        this.display.setAttribute("class", "display");
        this.div.append(this.display);

        this.hint = document.createElement("p");
        this.hint.innerText = gridX + "," + gridY + " " + cellX + "," + cellY;
        this.hint.setAttribute("class", "hint");
        this.div.append(this.hint);

        this.gridX = gridX;
        this.gridY = gridY;
        this.cellX = cellX;
        this.cellY = cellY;

        this.canChange = true;
        this.currentValue = 0;
        this.setCurrentValue(0);
    }

    setCurrentValue(val)
    {
        if(this.canChange) {
            this.currentValue = val;
            this.display.innerText = "" + val;
        }
    }

    setCanChange(val)
    {
        this.canChange = val;
    }
}

class Sudoku {
    constructor(parent) {
        this.parent = parent;
        this.grid = Array();

        this.build();
    }

    build() {
        for(var gridX = 0; gridX < 3; gridX++)
        {
            for(var gridY = 0; gridY < 3; gridY++)
            {
                var section = document.createElement("div");
                section.setAttribute("class", "section");

                for(var cellX = 0; cellX < 3; cellX++)
                {
                    for(var cellY = 0; cellY < 3; cellY++)
                    {
                        var cell = new Cell(gridX, gridY, cellX, cellY);
                        section.append(cell.div);
                        
                        this.addToArr(gridX, gridY, cellX, cellY, cell);
                    }
                }

                main.append(section);
            }
        }

        this.populateBoard();
    }

    addToArr(gridX, gridY, cellX, cellY, cell)
    {
        if(!this.grid[gridX])
        {
            this.grid[gridX] = new Array();
        }
        if(!this.grid[gridX][gridY])
        {
            this.grid[gridX][gridY] = new Array();
        }
        if(!this.grid[gridX][gridY][cellX])
        {
            this.grid[gridX][gridY][cellX] = new Array();
        }

        this.grid[gridX][gridY][cellX][cellY] = cell;
    }

    preAssignValue(value, overallDepth = 0)
    {
        if(overallDepth > 5) {
            console.log("nah dawg");
            return false;
        }
        var grids = new Array();
        var cells = new Array();
        for(var i = 0; i < 9; i++)
        {
            grids.push(i);
            cells.push(i);
        }

        var stackDepth = 0;
        console.log("assigning " + value);

        while(stackDepth < 30 && grids.length > 0 && cells.length > 0) {
            var gPos = Math.floor(Math.random() * grids.length);
            var gY = Math.floor(grids[gPos] / 3);
            var gX = grids[gPos] % 3;
            var cPos = Math.floor(Math.random() * cells.length);
            var cY = Math.floor(cells[cPos] / 3);
            var cX = cells[cPos] % 3;
            //console.log(grids[gPos] + " " + gX + "," + gY + " | " + cells[cPos] + " " + cX + "," + cY);

            if(this.grid[gX][gY][cX][cY].currentValue == 0)
            {
                if(this.checkGridFor(gX, gY, value))
                {
                    if(this.checkColFor(gX, cX, value))
                    {
                        if(this.checkRowFor(gY, cY, value)) {
                            this.grid[gX][gY][cX][cY].setCurrentValue(value);

                            //console.log("remove " + grids[gPos] + " from grid");
                            grids.splice(gPos, 1);
                            //console.log("remove " + cells[cPos] + " from cells");
                            cells.splice(cPos, 1);
                        }
                        else
                        {
                            //.log("dupe val in row");
                        }
                    }
                    else
                    {
                        //.log("dupe val in col");
                    }
                }
            }
            else 
            {
                //console.log("value already set, retry");
            }

            stackDepth++;
        }

        if(stackDepth > 29) 
        {
            this.clearValueFromBoard(value);
            this.preAssignValue(value, overallDepth++);
            console.log("error out due to stack-depth");
        }
        return true;
    }

    checkColFor(gX, cX, val)
    {
        for(var i = 0; i < 9; i++)
        {
            var gY = Math.floor(i / 3);
            var cY = i % 3;
            
            if(this.grid[gX][gY][cX][cY].currentValue == val)
            {
                return false;
            }
        }
        return true;
    }

    checkGridFor(gX, gY, val) 
    {
        for(var i = 0; i < 9; i++)
        {
            var cY = Math.floor(i / 3);
            var cX = i % 3;
            
            if(this.grid[gX][gY][cX][cY].currentValue == val)
            {
                return false;
            }
        }

        return true;
    }

    checkRowFor(gY, cY, val)
    {
        for(var i = 0; i < 9; i++)
        {
            var gX = Math.floor(i / 3);
            var cX = i % 3;
            
            if(this.grid[gX][gY][cX][cY].currentValue == val)
            {
                return false;
            }
        }

        return true;
    }

    clearValueFromBoard(value)
    {
        console.log("clearing " + value);
        for(var i = 0; i < 9; i++)
        {
            var gX = Math.floor(i / 3);
            var gY = i % 3;
            for(var j = 0;  j < 9; j++) {
                var cX = Math.floor(j / 3);
                var cY = j % 3;
                if(this.grid[gX][gY][cX][cY].currentValue == value)
                {
                    this.grid[gX][gY][cX][cY].setCurrentValue(0);
                }
            }
        }
    }

    populateBoard()
    {
        var sectionVals = Array();
        for(var i = 1; i < 10; i++)
        {
            sectionVals.push(i);
        }
        var clearedVals = Array();

        while(sectionVals.length > 0) {
            var randomValue = Math.floor(Math.random() * sectionVals.length);

            if(this.preAssignValue(sectionVals[randomValue], 0))
            {
                console.log("assigned " + sectionVals[randomValue]);
                clearedVals.push(sectionVals[randomValue]);
                sectionVals.splice(randomValue, 1);
            }
            else
            {
                console.log("removing " + clearedVals[clearedVals.length - 1] + " and trying again")
                this.clearValueFromBoard(clearedVals[clearedVals.length - 1]);
                sectionVals.push(clearedVals[clearedVals.length - 1]);
                sectionVals.pop();
            }
        }
    }

}
</script>